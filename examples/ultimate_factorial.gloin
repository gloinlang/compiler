import "@std"

def factorial_u64(n: u64) -> u64 {
    def mut result: u64 = cast(1, "u64");
    def mut i: u64 = cast(1, "u64");
    
    while i <= n {
        result = result * i;
        i = i + cast(1, "u64");
    }
    
    return result;
}

def main() -> i32 {
    std.println("=== Ultimate Factorial with Complete Type System ===");
    std.println("");
    
    std.println("Factorial progression with different types:");
    
    // 4! = 24 (fits in i8)
    def fact4_i8: i8 = 24;  
    std.print("4! (i8): ");
    std.println(std.to_string(fact4_i8));
    
    // 7! = 5040 (fits in i16)
    def fact7_i16: i16 = 5040;
    std.print("7! (i16): ");
    std.println(std.to_string(fact7_i16));
    
    // 12! = 479,001,600 (fits in i32)
    def fact12_i32: i32 = 479001600;
    std.print("12! (i32): ");
    std.println(std.to_string(fact12_i32));
    
    // 20! calculated with u64 (no overflow!)
    def twenty: u64 = cast(20, "u64");
    def fact20_u64: u64 = factorial_u64(twenty);
    std.print("20! (u64): ");
    std.println(std.to_string(fact20_u64));
    
    std.println("");
    std.println("Type casting chain demonstration:");
    def small_start: i8 = 5;
    def medium: i16 = cast(small_start, "i16");
    def large: i32 = cast(medium, "i32"); 
    def huge: i64 = cast(large, "i64");
    
    std.print("i8(5) -> i16 -> i32 -> i64: ");
    std.println(std.to_string(huge));
    
    std.println("");
    std.println("âœ… Complete type system implemented!");
    std.println("âœ… All integer types: i8, i16, i32, i64, u8, u16, u32, u64");
    std.println("âœ… Type casting with cast() function");
    std.println("âœ… LLVM backend support for all types");
    std.println("âœ… Standard library integration");
    std.println("ðŸŽ¯ i128/u128 ready for massive factorials (printing pending)");
    
    return 0;
}