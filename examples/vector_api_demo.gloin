import "@std"

def struct Vector_i32 {
    data: *i32;
    size: i32;
    capacity: i32;
}

def vector_new() -> Vector_i32 {
    def byte_size: i64 = cast(16, "i64");  // 4 elements * 4 bytes each
    def raw_ptr: *i8 = std.malloc(byte_size);
    
    // Work around pointer casting issue by using a different approach
    def vec: Vector_i32 = Vector_i32 {
        data: cast(0, "i32"),  // Use dummy value for now
        size: 0,
        capacity: 4
    };
    
    // We'll store the raw pointer value somehow
    return vec;
}

def vector_size(vec: *Vector_i32) -> i32 {
    return vec.size;
}

def vector_capacity(vec: *Vector_i32) -> i32 {
    return vec.capacity;
}

def vector_empty(vec: *Vector_i32) -> bool {
    return vec.size == 0;
}

def vector_push_back(vec: *Vector_i32, value: i32) -> void {
    if vec.size < vec.capacity {
        // For now, just increment size
        // TODO: Actual element storage needs pointer arithmetic
        vec.size = vec.size + 1;
    }
}

def vector_clear(vec: *Vector_i32) -> void {
    vec.size = 0;
}

def vector_resize(vec: *Vector_i32, new_size: i32) -> void {
    if new_size <= vec.capacity {
        vec.size = new_size;
    }
}

def main() -> i32 {
    std.println("=== Vector API Demonstration ===");
    std.println("");
    
    std.println("Creating vector...");
    def mut vec: Vector_i32 = vector_new();
    std.print("Initial size: ");
    std.println(std.to_string(vector_size(&vec)));
    std.print("Initial capacity: ");
    std.println(std.to_string(vector_capacity(&vec)));
    
    std.println("");
    std.println("Testing empty state...");
    if vector_empty(&vec) {
        std.println("âœ… Vector is empty (correct)");
    }
    
    std.println("");
    std.println("Adding elements...");
    vector_push_back(&vec, 42);
    vector_push_back(&vec, 100);
    vector_push_back(&vec, 256);
    std.print("Size after adding 3 elements: ");
    std.println(std.to_string(vector_size(&vec)));
    
    if !vector_empty(&vec) {
        std.println("âœ… Vector is no longer empty (correct)");
    }
    
    std.println("");
    std.println("Testing resize...");
    vector_resize(&vec, 2);
    std.print("Size after resize(2): ");
    std.println(std.to_string(vector_size(&vec)));
    
    std.println("");
    std.println("Testing clear...");
    vector_clear(&vec);
    std.print("Size after clear(): ");
    std.println(std.to_string(vector_size(&vec)));
    
    if vector_empty(&vec) {
        std.println("âœ… Vector is empty after clear (correct)");
    }
    
    std.println("");
    std.println("ðŸŽ‰ Vector API working correctly!");
    std.println("");
    std.println("ðŸ“‹ Implemented methods:");
    std.println("  âœ… vector_new()        - Constructor");
    std.println("  âœ… vector_size()       - Get element count");  
    std.println("  âœ… vector_capacity()   - Get allocation size");
    std.println("  âœ… vector_empty()      - Check if empty");
    std.println("  âœ… vector_push_back()  - Add element (structure only)");
    std.println("  âœ… vector_clear()      - Remove all elements");
    std.println("  âœ… vector_resize()     - Change size");
    std.println("");
    std.println("ðŸ”§ Still needed:");
    std.println("  ðŸ”„ Element storage with pointer arithmetic");
    std.println("  ðŸ”„ Element access: vec[index] or at(index)");
    std.println("  ðŸ”„ pop_back(), front(), back()");
    std.println("  ðŸ”„ Automatic capacity doubling");
    std.println("  ðŸ”„ Memory management integration");
    
    return 0;
}